#+title: A gentle introduction to Common Lisp

* Preface

I thought taking advantage of =org-babel= would be nice as one works
through programming books. It encourages you to play around while
taking notes, or just organizing your scratch when you don't take any
notes (which is more up my alley). It's easy to find these books
rather boring, but I think that's due to a lack of engagement (not
doing the exercises). If it's frictionless, then it's a little
rewarding to use the knowledge you just acquired. Only by involving
yourself will you remember and learn something.

Although I got through a good portion of the book by skimming, now
I'll restart and go through the exercises, putting concepts into my
own words when necessary.


* Chapter 1: Functions and Data
Mostly a cursory overview on how computer languages work.

#+begin_src lisp
  ;; ratios
  (/ 8 2)
  (/ 2 8)

  ;; 1.1 exercise answers
  ;; 13
  ;; 3
  ;; /
  ;; 3
  ;; 3
  ;; -48
  ;; 5/3
  (/ 15 9)
  ;; 0
  (+ 8 0)
  ;; -
  (- 5 6)
  ;; 2/3
  (- 1 1/3)
  ;; 2
  (abs (+ -5 3))

#+end_src

** symbols
My initial understanding of symbols are that they're just pointers. A
more convenient way to reference data.
BUT symbols can exist without any reference. I'm sure this'll clear up
more later on.
i.e.
#+begin_src lisp
(symbol-value 'cat)
#+end_src
Throws an error.

*** 1.2 exercise answers
S, I, S, S, I, I, I, S, S, I, I, S

** predicates

#+begin_src lisp
  (numberp 2)
  (symbolp 'cat)
  (zerop 0)
  (oddp 3)
  (evenp 29)
  (< 2 3)
  (< 3 2)
  (> 2 3)

  (equalp 1 1.0)
#+end_src

*** 1.3 exercise
#+begin_src lisp
  ;; t
  (< 7 11)
  ;; nil
  (oddp 12)
  ;; nil
  ;; t
  ;; t
  (< -4 -3)
  ;; t
  ;; nil
  (equal -9 9)
#+end_src

** creating functions

#+begin_src lisp
  (defun add1 (n)
    (+ n 1))

  (add1 5)

  (defun add2 (n)
    (add1
     (add1 n)))

  (add2 5)

  (defun twop (n)
    (equal 2 n))
  (twop 2)
#+end_src
*** exercises
#+begin_src lisp
  ;; define a sub2 func that subs two from input
  (defun sub2 (n)
    (- n 2))

  (sub2 2)
  ;; show how to write twop in terms of zerop and sub2
  (defun twop (n)
    (zerop
     (sub2 n)))

  (twop 2)
  ;; the half func returns num one-half of its input
  ;; show how to define half two diff ways
  (defun half (n)
    (/ n 2))

  (defun half (n)
    (* 0.5 n))

  (half 10)

  ;; write multi-digit-p pred that ret true if input is > 9
  (defun multi-digit-p (n)
    "Returns true if N has more than 1 digit"
    (> (abs n) 9))

  (multi-digit-p -9)
  (multi-digit-p -11)

  ;; following function negates the input
  (defun negate (n)
    (- 0 n))
  (negate 9)

  ;; 1.9
  (defun twomorep (x y)
    (equal x (add2 y)))
  (twomorep 9 7)

  ;; 1.10
  (defun twomorep (x y)
    (equal (sub2 x) y))
  (twomorep 9 7)

  ;; 1.11
  (defun average (x y)
    (/ (+ x y) 2))
  (average 10 20)

  ;; 1.12
  (defun more-than-half-p (x y)
    (> x (/ y 2)))

  (more-than-half-p 4 6)

  ;; 1.13: true, since nil or t are symbols and those are the only
  ;; available return values from numberp
#+end_src

** not predicate/negating predicate
*** exercises
#+begin_src lisp
  ;; 1.14
  ;; t
  (not nil)
  ;; nil
  (not 12)
  ;; nil
  (not #'not)

  ;; 1.15 write pred not-onep that ret T if input != 1
  (defun not-onep (n)
    (not (equal 1 n)))
  (not-onep 2)

  ;; 1.16 write pred not-plusp that ret t if input not > 0
  (defun not-plusp (n)
    (not (> n 0)))
  (not-plusp -3)

  ;; 1.17
  (defun my-evenp (n)
    (not (oddp n)))
  (my-evenp 2)

  ;; .18, returns T if N = -2
  (defun pred18 (n)
    (zerop 
     (add1
      (add1 n))))
  (pred18 -2)

  ;; .19 nil -> nil
  ;; t -> t
  ;; not all data, symbols are transformed to t
  (defun dubnot (n)
    (not (not n)))
  (dubnot nil)
  (dubnot t)
  (dubnot 'mysym)

  ;; .20 write xor
  (defun xor (x y)
    (not (equal x y)))
  (xor t nil)
  (xor t t)
  (xor nil nil)
  
#+end_src
** multiple inputs
additive functions are applied w/ multiple while order dependent funcs
clump last args and apply to first
#+begin_src lisp
  (* 50 3 4)
  (- 50 3 4)
  (/ 50 25 2)
  (/ 50)
  (- 4)
  (equal)
#+end_src
** errors
*** exercises
1.21, in order of appearance
- func is adding to a symbol
- equal not supplied 2 args
- not is supplied with too many args

** review
- 1.22 Yes, all predicates are functions, but not all functions are
predicates.
- 1.23 equal, not
- 1.24 NUMBER is not a number, is a symbol. And SYMBOL is another
  symbol.
- 1.25 because FALSE is a symbol, and symbols eval to T. False is
  represented by NIL
- 1.26 a) false, example: < or > do not accept t/nil. (b) is true.
- 1.27:
#+begin_src lisp
  (evenp 'symbol) ;; wrong type input, evenp expects number
  (evenp 2 4) ;; wrong-number-of-inputs error, as evenp wanats only 1 arg
#+end_src



* Chapter 2: Lists
The most important data type :~)
They're composed like linked lists in c, composed of =cons cells=.
2.1 would look the same as the rgb list

2.5
- 5
- 3
- 4
- 3
- 5
- 5

nil and () are equal, only symbol that is a list as well
#+begin_src lisp
    (equal () nil)
  (length nil)
  '((()))
#+end_src
2.6
- () -> nil
- (()) -> (nil)
- ((())) -> ((nil))
- (() ()) -> (nil nil)
- (() (())) -> (nil (nil))

** list extraction
#+begin_src lisp
  (first '(a b c d))
  (second '(a b c d))
  (third '(a b c d))
  (rest '(a b c d))

  (defun my-second (lst)
    (first (rest lst)))

  (my-second '(a b c d))

  ;; 2.8
  (defun my-third (lst)
    (first (rest (rest lst))))
  (my-third '(a b c d ))
  ;; 2.9 use second instead
  (defun my-third (lst)
    (second (rest lst)))

#+end_src

** car/cdr

Car goes inside, while cdr goes to the next.
#+begin_src lisp
  (car '(a b c))
  (cdr '(a b c))
  (cdr '(a))
  (cadr '(a b c))
  (cdar '((a b) b c))
  (caddr '(a b c d))
  ;; 2.12 "ka-dih-dih-der"   
  (cadddr '(a b c d))

  (cadar '((blue cube) (red pyramid)))
  ;; 2.13
  (caaar '(((fun)) (in the) (sun)))
  (caadr '(((fun)) (in the) (sun)))
  (cadadr '(((fun)) (in the) (sun)))
  (caaddr '(((fun)) (in the) (sun)))
  ;; 2.15
  (car '((a b) (c d) (e f)))
  ;; ((e f))
  (cddr '((a b) (c d) (e f)))
  ;; (c d)
  (cadr '((a b) (c d) (e f)))
  ;; cadar -> b
  (cadar '((a b) (c d) (e f)))
  ;; cddar -> nil
  (cddar '((a b) (c d) (e f)))
  ;; caar -> a
  (caar '((a b) (c d) (e f)))
  ;; cdaddr -> (f) 
  (cdaddr '((a b) (c d) (e f)))
  ;; cadaddr -> f, but not supported(..?)
  (car  (cdaddr '((a b) (c d) (e f))))

  ;; 2.17
  ;; post
  (car '(post no bills))
  ;; (no bills)
  (cdr '(post no bills))
  ;; (post no)
  (car '((post no) bills))
  ;; nil
  (cdr '(bills))
  ;; undefined
  (car bills)
  ;; ((no bills))
  (cdr '(post (no bills)))
  ;; nil
  (cdr '((post no bills)))
  ;; nil
  (car nil)

#+end_src

** cons

#+begin_src lisp

  (cons 'a '(b c d))

  (defun greet (lst)
    (cons 'hello lst))

  (greet '(professor higgins))

  (cons 'a nil)

  (cons nil nil)

  (cons '(a b) nil)

  ;; 2.18
  (defun my-make-list (x y)
    (cons x (cons y nil)))
  (my-make-list 'fred 'george)
#+end_src

** list
2.19
- (fred and wilma)
- (fred (and wilma))
- (fred and wilma)
- (nil)
- (nil nil)

#+begin_src lisp
  (defun say-what (lst)
    (cons 'what (cdr lst)))
  (say-what '(take a nap))
#+end_src

2.20
- (nil)
- (t nil)
- (t)
- ((t))
- ((in one ear and) (out the other))
- ((in one ear and) out the other)
#+begin_src lisp

  ;; 2.21

  (defun make-nested-tuple (w x y z)
    (list (list w x)
          (list y z)))
  (make-nested-tuple 'a 'b 'c 'd)
  ;; 2.22

  (defun duo-cons (x y z)
    "add two elements to list w/ cons"
    (cons x (cons y z)))
  (duo-cons 'x 'y '(z))

  ;; 2.23

  (defun two-deeper (lst)
    "add two levels of parens"
    (cons (cons  lst nil) nil))

  (defun two-deeper (lst)
    (list (list lst)))
  (two-deeper 'a)

  ;; 2.24
  (cdr '(((good)) ((night))))
  (caaadr '(((good)) ((night))))
  ;; need to remember that cdr preserves parent parens
#+end_src

** lst predicates

#+begin_src lisp

  (listp nil)
  (consp nil)
  (atom nil)
  (atom 18)
  (null nil)
#+end_src
** review
- 2.25 why do cons cells and cons function share same name?
  because we're creating a cons cell with the cons function.
- 2.26 returns 2 for the first, nil for the second
- 2.27 when the elements themselves are lists
- 2.28, yes, it is possible, as cdr moves the pointer forward and car
  helps navigate nested lists. It may be an extremely long function
  depending on the list, but it's possible, since with both we can
  select every element, as the list is made of cons cells
  
#+begin_src lisp
  ;; 2.29

  (defun unary-add1 (lst)
    (cons 'x lst))
  (unary-add1 '(x x x))
  ;; 2.30 -> subtracts 2
  ;; 2.31
  (defun unary-zerop (lst)
    (zerop (length lst)))
  (unary-zerop nil)
  ;; 2.32
  (defun unary-greaterp (x y)
    (> (length x) (length y)))
  (unary-greaterp '(x y z) '(y z))
  ;; 2.33
  ;; car checks whether the unary number is greater than zero

  (cons 'a 'b)
  ;; 2.34
  (cons 'a
        (cons 'b
              (cons 'c
                    'd)))
  ;; 2.36 since creating lists with only cons requires you to first
  ;; define the end, one cannot set the inside cons cell to the final
  ;; cons cell upon creation. You need a variable

#+end_src

* Chapter 3: eval

#+begin_src lisp
  ;; 3.5
  (defun half (x)
    (/ x 2))
  (half 4)

  (defun cube (x)
    (* x x x))
  (cube 3)

  (defun pythag (x y)
    (sqrt (+ (* x x)
             (* y y))))
  (pythag 3 4)

  (defun miles-per-gallon (init final gals)
    (/ (- final init) gals))
  (miles-per-gallon 10 30 10)
#+end_src

** variables
3.9
- (cons 5 (list 6 7)) -> (5 6 7)
- (cons 5 '(list 6 7)) -> (5 list 6 7)
- (3 from 9 gives 6)
- 6
- (is short for construct)
3.10
#+begin_src lisp
  (third '(the quick brown fox))
  ;; undefined symbol
  (list 2 'and 2 'is 4)
  ;; incorrect type, need to eval length
  (+ 1 (length (list t t t t)))
  ;; undefined list
  (cons 'patrick '(seymour marvin))
  ;; undefined symbols
  (cons 'patrick (list 'seymour 'marvin))
  ;; 3.11
  (defun longer-than (x y)
    (> (length x) (length y)))
  (longer-than '(a b c) '(a b))
  ;; 3.12
  (defun addlength (lst)
    (cons (length lst) lst))
  (addlength '(a b))
  ;; 4 3 a b c
  (addlength (addlength '(a b c)))
  ;; 3.13
  ;; -> 2 params
  ;; -> caller, callee
  ;; (hello wanda this is fred speaking)
  ;; no variable substitution


#+end_src

* Chapter 4: Conditionals

** if
#+begin_src lisp
  (if (oddp 1) 'odd 'even)
  (defun my-abs (x)
    (if (< x 0) (- x) x))
  (my-abs -5)
  (my-abs 5)

  ;; 4.1
  (defun make-even (x)
    (if (oddp x) (+ x 1) x))
  (make-even 3)
  (make-even 4)

  ;; 4.2
  (defun further (x)
    (if 4))

  ;; 4.3
  (defun my-not (x)
    (if (x) nil t))
  ;; 4.4
  (defun ordered (x y)
    (if (> x y) (list y x) (list x y)))
  (ordered 4 3)

  ;; 4.6
  (defun my-abs (x)
    (cond ((< x 0) (- x))
          ((> x 0) x)
          (t x)))
  (my-abs -3)
  (my-abs 0)

  ;; 4.8
  (defun emphasize3 (x)
    (cond ((equal (first x) 'good) (cons 'great (rest x)))
          ((equal (first x) 'bad) (cons 'horrible (rest x)))
          (t (cons 'very x))))
  (emphasize3 '(good day))
  (emphasize3 '(bad day))
  (emphasize3 '(long day))


  ;; 4.9 it always evals to t first
  (defun make-odd (x)
    (cond ((not (oddp x)) (+ x 1))
          (t x)))
  (make-odd 3)
  (make-odd 4)

  ;; 4.10

  (defun constrain (x max min)
    (cond
      ((< x min) min)
      ((> x max) max)
      (t x)))
  (constrain 5 10 3)
  (constrain 2 10 3)
  (constrain 11 10 3)

  ;; 4.11
  (defun firstzero (lst)
    (cond
      ((equal (first lst) 0) 'first)
      ((equal (second lst) 0) 'second)
      ((equal (third lst) 0) 'third)
      (t 'none)))
  (firstzero '(1 0 3))
  (firstzero '(3 1 0))
  (firstzero '(1 0 3))
  (firstzero '(1 1 3))

  ;; 4.12
  (defun cycle (x)
    (cond
      ((< x 99) (+ x 1))
      (t 1)))
  (cycle 1)
  (cycle 99)
  ;; 4.13
  (defun howcompute (x y res)
    (cond
      ((equal (+ x y) res) 'sum-of)
      ((equal (* x y) res) 'product-of)
      (t 'beats-me)))
  ;; could extend it to the other operations, like quotient of

#+end_src

** and/or macros

#+begin_src lisp
  (defun small-positive-oddp (x)
    (and (< x 100)
         (> x 0)
         (oddp x)))


  ;; 4.15
  (defun geq (x y)
    (or (> x y) (equal x y)))
  (geq 4 3)
  (geq 4 4)
  (geq 4 5)
  ;; 4.16

  (defun cond-sqaure (x)
    (cond ((and (oddp x) (> x 0)) (* x x))
          ((and (oddp x) (< x 0)) (* x 2))
          (t (/ x 2))))

  ;; 4.17
  (defun match (s a)
    (or (and (or (equal s 'boy)
                 (equal s 'girl))
             (equal a 'child))
        (and (or (equal s 'man)
                 (equal s 'woman))
             (equal a 'adult))))
  ;; 4.18
  (defun play (p1 p2)
    (cond ((equal p1 p2) 'tie)
          ((is-winner p1 p2) 'first-wins)
          ((is-winner p2 p1) 'second-wins)
          (t 'error)))

  (defun is-winner (player opponent)
    (or (and (equal player 'rock)
             (equal opponent 'scissors))
        (and (equal player 'scissors)
             (equal opponent 'paper))
        (and (equal player 'paper)
             (equal opponent 'rock))))

  (play 'rock 'scissors)
  (play 'scissors 'rock)
  (play 'scissors 'scissors)
  (play 'scissors 'paper)
  (play 'paper 'scissors)
#+end_src

* Chapter 5: Variables

#+begin_src lisp
  (defun average (x y)
    (let ((sum (+ x y)))
      (list x y 'average 'is (/ sum 2.0))))


  (average 8 10)

  (defun poor-style (p)
    (setf p (+ p 5))
    (list 'result 'is p))
  ;; 5.1
  (defun let-style (p)
    (let ((p5 (+ p 5)))
      (list 'result 'is p5)))

  (let-style 5)

  ;; let* does in order assignment, one at a time

  (defun correct-size-range (x y z)
    (let* ((biggest (max x y z))
           (smallest (min x y z))
           (r (/ biggest smallest 1.0)))
      (list 'factor 'of r)))
  (step

 
   (correct-size-range 35 87 4))
  ;; 5.4 because it needs to skip over evaluating the variable name upon
  ;; declaration
  ;; 5.5 I believe so.

  ;; 5.6
  (defun throw-die ()
    "Returns a random number from 1 to 6"
    (+ 1 (random 6)))
  (throw-die)
  (defun throw-dice ()
    (let ((d1 (throw-die))
          (d2 (throw-die)))
      (list d1 d2)))
  (throw-dice)

  (defun snake-eyes-p (throw-outcome)
    (equal throw-outcome '(1 1)))
  (snake-eyes-p '(1 1))

  (defun boxcars-p (throw-outcome)
    (equal throw-outcome '(6 6)))
  (boxcars-p '(6 6))

  (defun instant-win-p (throw-outcome)
    (or (equal 7 (reduce '+ throw-outcome))
        (equal 11 (reduce '+ throw-outcome))))
  (instant-win-p '(5 6))

  (defun instant-loss-p (throw-outcome)
    (or (equal 2 (reduce '+ throw-outcome))
        (equal 3 (reduce '+ throw-outcome))
        (equal 12 (reduce '+ throw-outcome))))
  (instant-loss-p '(6 6))

  (defun say-throw (throw-outcome)
    (cond ((snake-eyes-p throw-outcome) 'snakeeyes)
          ((boxcars-p throw-outcome) 'boxcars)
          (t  (reduce '+ throw-outcome))))
  (say-throw '(1 1))
  (say-throw '(6 6))
  (say-throw '(1 6))

  (defun craps ()
    (let* ((throw-outcome (throw-dice))
           (throw-saying (say-throw throw-outcome))
           (throw-result-print (list 'throw (car throw-outcome) 'and (cadr throw-outcome))))
      (cond ((instant-win-p throw-outcome) (append throw-result-print (list '-- throw-saying '-- 'you 'win)))
            ((instant-loss-p throw-outcome) (append throw-result-print (list '-- throw-saying '-- 'you 'lose)))
            (t (append throw-result-print  (list '-- 'your 'point 'is throw-saying))))))
  (craps)
;; could make this more efficient
  (defun try-for-point (n)
    (let ((throw-outcome (throw-dice)))
      (cond ((equal n (reduce '+ throw-outcome))
             (list 'throw (car throw-outcome) 'and (cadr throw-outcome) '-- (say-throw throw-outcome) '-- 'you 'win))
            ((equal 7 (reduce '+ throw-outcome))
             (list 'throw (car throw-outcome) 'and (cadr throw-outcome) '-- (say-throw throw-outcome) '-- 'you 'lose))
            (t
             (list 'throw (car throw-outcome) 'and (cadr throw-outcome) '-- (say-throw throw-outcome) '-- 'throw 'again)))))

  (try-for-point 6)


#+end_src
