#+title: A gentle introduction to Common Lisp

* Preface

I thought taking advantage of =org-babel= would be nice as one works
through programming books. It encourages you to play around while
taking notes, or just organizing your scratch when you don't take any
notes (which is more up my alley). It's easy to find these books
rather boring, but I think that's due to a lack of engagement (not
doing the exercises). If it's frictionless, then it's a little
rewarding to use the knowledge you just acquired. Only by involving
yourself will you remember and learn something.

Although I got through a good portion of the book by skimming, now
I'll restart and go through the exercises, putting concepts into my
own words when necessary.


* Chapter 1: Functions and Data
Mostly a cursory overview on how computer languages work.

#+begin_src lisp
  ;; ratios
  (/ 8 2)
  (/ 2 8)

  ;; 1.1 exercise answers
  ;; 13
  ;; 3
  ;; /
  ;; 3
  ;; 3
  ;; -48
  ;; 5/3
  (/ 15 9)
  ;; 0
  (+ 8 0)
  ;; -
  (- 5 6)
  ;; 2/3
  (- 1 1/3)
  ;; 2
  (abs (+ -5 3))

#+end_src

** symbols
My initial understanding of symbols are that they're just pointers. A
more convenient way to reference data.
BUT symbols can exist without any reference. I'm sure this'll clear up
more later on.
i.e.
#+begin_src lisp
(symbol-value 'cat)
#+end_src
Throws an error.

*** 1.2 exercise answers
S, I, S, S, I, I, I, S, S, I, I, S

** predicates

#+begin_src lisp
  (numberp 2)
  (symbolp 'cat)
  (zerop 0)
  (oddp 3)
  (evenp 29)
  (< 2 3)
  (< 3 2)
  (> 2 3)

  (equalp 1 1.0)
#+end_src

*** 1.3 exercise
#+begin_src lisp
  ;; t
  (< 7 11)
  ;; nil
  (oddp 12)
  ;; nil
  ;; t
  ;; t
  (< -4 -3)
  ;; t
  ;; nil
  (equal -9 9)
#+end_src

** creating functions

#+begin_src lisp
  (defun add1 (n)
    (+ n 1))

  (add1 5)

  (defun add2 (n)
    (add1
     (add1 n)))

  (add2 5)

  (defun twop (n)
    (equal 2 n))
  (twop 2)
#+end_src
*** exercises
#+begin_src lisp
  ;; define a sub2 func that subs two from input
  (defun sub2 (n)
    (- n 2))

  (sub2 2)
  ;; show how to write twop in terms of zerop and sub2
  (defun twop (n)
    (zerop
     (sub2 n)))

  (twop 2)
  ;; the half func returns num one-half of its input
  ;; show how to define half two diff ways
  (defun half (n)
    (/ n 2))

  (defun half (n)
    (* 0.5 n))

  (half 10)

  ;; write multi-digit-p pred that ret true if input is > 9
  (defun multi-digit-p (n)
    "Returns true if N has more than 1 digit"
    (> (abs n) 9))

  (multi-digit-p -9)
  (multi-digit-p -11)

  ;; following function negates the input
  (defun negate (n)
    (- 0 n))
  (negate 9)

  ;; 1.9
  (defun twomorep (x y)
    (equal x (add2 y)))
  (twomorep 9 7)

  ;; 1.10
  (defun twomorep (x y)
    (equal (sub2 x) y))
  (twomorep 9 7)

  ;; 1.11
  (defun average (x y)
    (/ (+ x y) 2))
  (average 10 20)

  ;; 1.12
  (defun more-than-half-p (x y)
    (> x (/ y 2)))

  (more-than-half-p 4 6)

  ;; 1.13: true, since nil or t are symbols and those are the only
  ;; available return values from numberp
#+end_src

** not predicate/negating predicate
*** exercises
#+begin_src lisp
  ;; 1.14
  ;; t
  (not nil)
  ;; nil
  (not 12)
  ;; nil
  (not #'not)

  ;; 1.15 write pred not-onep that ret T if input != 1
  (defun not-onep (n)
    (not (equal 1 n)))
  (not-onep 2)

  ;; 1.16 write pred not-plusp that ret t if input not > 0
  (defun not-plusp (n)
    (not (> n 0)))
  (not-plusp -3)

  ;; 1.17
  (defun my-evenp (n)
    (not (oddp n)))
  (my-evenp 2)

  ;; .18, returns T if N = -2
  (defun pred18 (n)
    (zerop 
     (add1
      (add1 n))))
  (pred18 -2)

  ;; .19 nil -> nil
  ;; t -> t
  ;; not all data, symbols are transformed to t
  (defun dubnot (n)
    (not (not n)))
  (dubnot nil)
  (dubnot t)
  (dubnot 'mysym)

  ;; .20 write xor
  (defun xor (x y)
    (not (equal x y)))
  (xor t nil)
  (xor t t)
  (xor nil nil)
  
#+end_src
** multiple inputs
additive functions are applied w/ multiple while order dependent funcs
clump last args and apply to first
#+begin_src lisp
  (* 50 3 4)
  (- 50 3 4)
  (/ 50 25 2)
  (/ 50)
  (- 4)
  (equal)
#+end_src
** errors
*** exercises
1.21, in order of appearance
- func is adding to a symbol
- equal not supplied 2 args
- not is supplied with too many args

** review
- 1.22 Yes, all predicates are functions, but not all functions are
predicates.
- 1.23 equal, not
- 1.24 NUMBER is not a number, is a symbol. And SYMBOL is another
  symbol.
- 1.25 because FALSE is a symbol, and symbols eval to T. False is
  represented by NIL
- 1.26 a) false, example: < or > do not accept t/nil. (b) is true.
- 1.27:
#+begin_src lisp
  (evenp 'symbol) ;; wrong type input, evenp expects number
  (evenp 2 4) ;; wrong-number-of-inputs error, as evenp wanats only 1 arg
#+end_src



* Chapter 2: Lists
The most important data type :~)
They're composed like linked lists in c, composed of =cons cells=.
2.1 would look the same as the rgb list

2.5
- 5
- 3
- 4
- 3
- 5
- 5

nil and () are equal, only symbol that is a list as well
#+begin_src lisp
    (equal () nil)
  (length nil)
  '((()))
#+end_src
2.6
- () -> nil
- (()) -> (nil)
- ((())) -> ((nil))
- (() ()) -> (nil nil)
- (() (())) -> (nil (nil))

** list extraction
#+begin_src lisp
  (first '(a b c d))
  (second '(a b c d))
  (third '(a b c d))
  (rest '(a b c d))

  (defun my-second (lst)
    (first (rest lst)))

  (my-second '(a b c d))

  ;; 2.8
  (defun my-third (lst)
    (first (rest (rest lst))))
  (my-third '(a b c d ))
  ;; 2.9 use second instead
  (defun my-third (lst)
    (second (rest lst)))

#+end_src

** car/cdr

Car goes inside, while cdr goes to the next.
#+begin_src lisp
  (car '(a b c))
  (cdr '(a b c))
  (cdr '(a))
  (cadr '(a b c))
  (cdar '((a b) b c))
  (caddr '(a b c d))
  ;; 2.12 "ka-dih-dih-der"   
  (cadddr '(a b c d))

  (cadar '((blue cube) (red pyramid)))
  ;; 2.13
  (caaar '(((fun)) (in the) (sun)))
  (caadr '(((fun)) (in the) (sun)))
  (cadadr '(((fun)) (in the) (sun)))
  (caaddr '(((fun)) (in the) (sun)))
  ;; 2.15
  (car '((a b) (c d) (e f)))
  ;; ((e f))
  (cddr '((a b) (c d) (e f)))
  ;; (c d)
  (cadr '((a b) (c d) (e f)))
  ;; cadar -> b
  (cadar '((a b) (c d) (e f)))
  ;; cddar -> nil
  (cddar '((a b) (c d) (e f)))
  ;; caar -> a
  (caar '((a b) (c d) (e f)))
  ;; cdaddr -> (f) 
  (cdaddr '((a b) (c d) (e f)))
  ;; cadaddr -> f, but not supported(..?)
  (car  (cdaddr '((a b) (c d) (e f))))

  ;; 2.17
  ;; post
  (car '(post no bills))
  ;; (no bills)
  (cdr '(post no bills))
  ;; (post no)
  (car '((post no) bills))
  ;; nil
  (cdr '(bills))
  ;; undefined
  (car bills)
  ;; ((no bills))
  (cdr '(post (no bills)))
  ;; nil
  (cdr '((post no bills)))
  ;; nil
  (car nil)

#+end_src

** cons

#+begin_src lisp

  (cons 'a '(b c d))

  (defun greet (lst)
    (cons 'hello lst))

  (greet '(professor higgins))

  (cons 'a nil)

  (cons nil nil)

  (cons '(a b) nil)

  ;; 2.18
  (defun my-make-list (x y)
    (cons x (cons y nil)))
  (my-make-list 'fred 'george)
#+end_src

** list
2.19
- (fred and wilma)
- (fred (and wilma))
- (fred and wilma)
- (nil)
- (nil nil)

#+begin_src lisp
  (defun say-what (lst)
    (cons 'what (cdr lst)))
  (say-what '(take a nap))
#+end_src

2.20
- (nil)
- (t nil)
- (t)
- ((t))
- ((in one ear and) (out the other))
- ((in one ear and) out the other)
#+begin_src lisp

  ;; 2.21

  (defun make-nested-tuple (w x y z)
    (list (list w x)
          (list y z)))
  (make-nested-tuple 'a 'b 'c 'd)
  ;; 2.22

  (defun duo-cons (x y z)
    "add two elements to list w/ cons"
    (cons x (cons y z)))
  (duo-cons 'x 'y '(z))

  ;; 2.23

  (defun two-deeper (lst)
    "add two levels of parens"
    (cons (cons  lst nil) nil))

  (defun two-deeper (lst)
    (list (list lst)))
  (two-deeper 'a)

  ;; 2.24
  (cdr '(((good)) ((night))))
  (caaadr '(((good)) ((night))))
  ;; need to remember that cdr preserves parent parens
#+end_src

** lst predicates

#+begin_src lisp

  (listp nil)
  (consp nil)
  (atom nil)
  (atom 18)
  (null nil)
#+end_src
** review
- 2.25 why do cons cells and cons function share same name?
  because we're creating a cons cell with the cons function.
- 2.26 returns 2 for the first, nil for the second
- 2.27 when the elements themselves are lists
- 2.28, yes, it is possible, as cdr moves the pointer forward and car
  helps navigate nested lists. It may be an extremely long function
  depending on the list, but it's possible, since with both we can
  select every element, as the list is made of cons cells
  
#+begin_src lisp
  ;; 2.29

  (defun unary-add1 (lst)
    (cons 'x lst))
  (unary-add1 '(x x x))
  ;; 2.30 -> subtracts 2
  ;; 2.31
  (defun unary-zerop (lst)
    (zerop (length lst)))
  (unary-zerop nil)
  ;; 2.32
  (defun unary-greaterp (x y)
    (> (length x) (length y)))
  (unary-greaterp '(x y z) '(y z))
  ;; 2.33
  ;; car checks whether the unary number is greater than zero

  (cons 'a 'b)
  ;; 2.34
  (cons 'a
        (cons 'b
              (cons 'c
                    'd)))
  ;; 2.36 since creating lists with only cons requires you to first
  ;; define the end, one cannot set the inside cons cell to the final
  ;; cons cell upon creation. You need a variable

#+end_src

* Chapter 3: eval
